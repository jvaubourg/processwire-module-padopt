<?php

/* PadOpt for PadLoper
 * Add custom client options feature to PadLoper (ProcessWire module) 
 *
 * Copyright (C) 2018 Julien Vaubourg <julien@vaubourg.com>
 * Contribute at https://github.com/jvaubourg/processwire-module-padopt
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 * 
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

ini_set('display_errors', 1);
ini_set('display_startup_errors', 1);
error_reporting(E_ALL);

class PadOpt extends WireData implements Module {

  // MySQL table name used by PadCart for storing carts
  protected $db_padcart = 'padcart'; 

  // MySQL table colunm name added by PadOpt in <db_padcart> to store product
  // options when they are added to the cart, before ordering
  protected $db_optcolumn = 'padopt_options';

  // Name of the field added by PadOpt in PadLoper product pages (admin-side)
  // to store product options, when the cart (MySQL) is transform into an order
  // (PW Page)
  protected $field_options_name = 'padopt_options';

  // Name of the field used in PadOpt product page, to ask the admin to choose
  // a template id on which the option input fields set will be built
  protected $field_tpl_name = 'padopt_tpl_id';

  // HTML forms for choosing options have to integrate an hidden input field
  // with this name (value=1)
  protected $input_padopt_enabled = 'padopt';

  // General prefix of PadOpt (eg. for field names)
  protected $general_prefix = 'padopt_';

  // Prefix part used in the name of general fields used to build option forms
  protected $input_prefix = 'input_';

  // Prefix part used in the name of fields used to describe a separator
  // (ie. title) in option forms
  protected $separator_prefix = 'sep_';

  // Fields and templates created in PW with a name beginning with
  // <general_prefix> will be automatically associated to this tag name
  protected $tag_name = 'padopt';

  // Errors will be logged under this category in PW and in JS console
  protected $log_name = 'padopt';

  protected $session_id;
  protected $stored_options = array();
  protected $registered_submodules = array();

  public static function getModuleInfo() {
    return array(
      'title' => 'PadLoper Client Options',
      'version' => 1,
      'summary' => 'Add custom client options to products for PadLoper',
      'icon' => 'cart-plus',
      'href' => 'https://github.com/jvaubourg/processwire-module-padopt',
      'author' => 'Julien Vaubourg',
      'singular' => true,
      'autoload' => true,
      'requires' => 'PadLoper',
    );
  }

  public function init() {

foreach($this->session as $name => $value) 
    $this->session_id = session_id();

    $this->addHookBefore('ProcessField::executeSave', $this, 'automaticTagging');
    $this->addHookBefore('ProcessTemplate::executeSave', $this, 'automaticTagging');
    $this->addHookAfter('ProcessPageEdit::buildForm', $this, 'addTemplateSelect');
    $this->addHookBefore('PadLoper::add', $this, 'storeProductOptions');
    $this->addHookAfter('PadCart::addProduct', $this, 'addProductOptionsToCart');
    $this->addHookAfter('PadOrder::parseCart', $this, 'convertCartWithOptionsToOrder');
    $this->addHookAfter('PadCart::getProductPrice', $this, 'customizePriceWithOptions');
    $this->addHookAfter('Page::render', $this, 'addScriptsAndStyles');
    $this->addHookAfter('PadProcess::executeViewOrder', $this, 'addOptionsToViewOrder');
  }


  /***********/
  /** HOOKS **/
  /***********/

  /**
   * Automatically add a <tag_name> tag to every new field and template created
   * with a name beginning by <general_prefix>. Also works after name updating
   * Act before ProcessField::executeSave and ProcessTemplate::executeSave
   */
  public function automaticTagging($event) {
    $post_values = $event->object->input->post;

    if((($post_values['name'] && strpos($post_values['name'], $this->general_prefix) === 0)
        || ($post_values['rename'] && strpos($post_values['rename'], $this->general_prefix) === 0))
      && strpos($post_values['tags'], $this->tag_name) === false) {

      $post_values['tags'] .= " {$this->tag_name}";
    }
  }

  /**
   * When an admin page is edited, replace the field named <field_tpl_name>
   * (simple input text for integers) by a select proposing to chose one of
   * the template available in PW. This is used when a PadOpt product page
   * is edited
   * Act after ProcessPageEdit::buildForm
   */
  public function addTemplateSelect($event) {
    $form = $event->return;
    $inputfield_int_id = $form->getChildByName($this->field_tpl_name);

    // Only pages proposing the target field (ie. PadOpt product pages)
    if($inputfield_int_id != null) {
      $inputfield_select_tpl = $this->modules->get('InputfieldSelect');

      $inputfield_select_tpl->name = $inputfield_int_id->name;
      $inputfield_select_tpl->label = __("Form");
      $inputfield_select_tpl->description = __("Choose the template you have created for defining the form to display on this page.");

      // Build a select with all available non-system templates in PW
      foreach($this->templates->getAll() as $key => $template) {
        if(!($template->flags & Template::flagSystem)) {
          $inputfield_select_tpl->addOption($key, $template);
        }
      }

      // The input text version of the field is removed
      $inputfield_select_tpl->value = $inputfield_int_id->value;
      $form->remove($inputfield_int_id);

      // ... and replaced by the new version with values to select
      $field_title = $form->getChildByName('title');
      $form->insertAfter($inputfield_select_tpl, $field_title);

      $event->return = $form;
    }
  }

  /**
   * Catch the value of every input field with a name beginning by
   * <general_prefix>, among the values transmitted by a page to PadLoper,
   * when an "Add to Cart" button is pushed. These values (describing product
   * options) are temporarily stored in an array, to be used later by
   * addProductOptionsToCart
   * Act before PadLoper::add
   */
  public function storeProductOptions($event) {
    $product_id = (int) $event->arguments('id');
    $variation_id = (int) $event->arguments('variation_id');

    if(!empty($product_id) && !empty($variation_id)) {
      $product_page = $event->object->pages->get($product_id);
  
      // Only for PadOpt product pages containing an input field named <input_padopt_enabled>
      // (have one condition respected but not the other one should neved happen)
      if($this->isPadoptProductPage($product_page) && ($event->object->input->post($this->input_padopt_enabled) == 1)) {

        if(!array_key_exists($this->session_id, $this->stored_options)) {
          $this->stored_options[$this->session_id] = array();
        }
  
        if(!array_key_exists($product_id, $this->stored_options[$this->session_id])) {
          $this->stored_options[$this->session_id][$product_id] = array();
        }
  
        if(!array_key_exists($variation_id, $this->stored_options[$this->session_id][$product_id])) {
          $this->stored_options[$this->session_id][$product_id][$variation_id] = array();
        }
  
        $options = &$this->stored_options[$this->session_id][$product_id][$variation_id];
  
        // Input values are stored only when the name begins with
        // <general_prefix>, corresponding to input fields generated
        // by PadOpt
        foreach($event->object->input->post as $name => $value) {
          if(strpos($name, $this->general_prefix) === 0) {
            $tpl_page = new Page();
            $tpl_page->template = $product_page->get($this->field_tpl_name);

            // Is the input field corresponding to a PW field for this PadOpt product page
            if($tpl_page->fields->get($name)) {

              // Pipes are special chars for us
              $value = str_replace('|', '', $value);
    
              // Values composed of multiple values (eg. checkboxes) are concatenated
              // into a single value (eg. 1|2|3)
              if(is_array($value)) {
                $value = implode('|', $value);
              }
    
              // sanitizer->text() allows 255 chars max and avoid db over filling
              if(strlen($value) > 0) {
                $value = substr($value, 0, 255);
    
                if(substr($value, -1) == '|') {
                  $value = substr($value, 0, 254);
                }
              }
    
              $options[$this->sanitizer->fieldName($name)] = $this->sanitizer->text($value);
            }
          }
        }
      }
    }
  }

  /**
   * Store in db the options associated to the product to add to the cart. The
   * values are serialized and saved in the <db_optcolumn> MySQL column of the
   * tuple, created for the current cart by PadLoper in the hooked function
   * Act after PadCart::addProduct
   */
  public function addProductOptionsToCart($event) {
    $product_id = (int) $event->arguments('product_id');
    $variation_id = (int) $event->arguments('variation_id');
    $qty = (int) $event->arguments('qty');

    // Only if the hooked function worked well (ie. the cart was well created in the db)
    if($event->return === true && $qty > 0) {

      // If storeProductOptions found earlier some options values to store for this product
      if(array_key_exists($this->session_id, $this->stored_options)
        && array_key_exists($product_id, $this->stored_options[$this->session_id])
        && array_key_exists($variation_id, $this->stored_options[$this->session_id][$product_id])) {

        // Get the id of the cart-product tuple in the db
        $cart_row_id = $event->object->checkIfProductInCart($product_id, $variation_id);
  
        if($cart_row_id) {
          $options = $this->stored_options[$this->session_id][$product_id][$variation_id];
	  $options['product_id'] = $product_id;
          $serialized_options = serialize($options);
  
          // Fill the <db_optcolumn> with all the option values associated to
          // this product when added in the cart by the client
          $sql = "UPDATE {$this->db_padcart} SET {$this->db_optcolumn} = :options WHERE sess_id = :sess_id AND id = :id";  
          $sth = $this->database->prepare($sql);
          $sth->bindParam(":options", $serialized_options);
          $sth->bindParam(":sess_id", $this->session_id);
          $sth->bindParam(":id", $cart_row_id);
          $sth->execute();

          // Free the temporary memory allocated for jumping from storeProductOptions
          // (values catching) to addProductOptionsToCart (values injecting)
          unset($this->stored_options[$this->session_id][$product_id][$variation_id]);
        }
      }
    }
  }

  /**
   * Move the product options stored into a db column when added to a cart, to
   * a PW field, when the cart is converted to an order (the order pad_product
   * page is created during the hooked function, and the db tuple is deleted
   * just after)
   * Act after PadOrder::parseCart
   */
  public function convertCartWithOptionsToOrder($event) {
    if($event->object->pad_products->count > 0) {

      // Get the options associated to this product and stored by addProductOptionsToCart
      $sql = "SELECT product_id, variation_id, {$this->db_optcolumn} FROM {$this->db_padcart} WHERE sess_id = :sess_id";
      $sth = $this->database->prepare($sql);
      $sth->bindParam(":sess_id", $this->session_id);
      $sth->execute();

      $cart_products = $sth->fetchAll(\PDO::FETCH_CLASS);

      foreach($cart_products as $cart_product) {

        // Only if this product was added with PadOpt options
        if(!empty($cart_product->{$this->db_optcolumn})) {
          $product_id = $cart_product->product_id;
          $variation_id = $cart_product->variation_id;

          // Get the pad_product page created for this product in the hooked function
          $order_product = $event->object->pad_products->get("pad_product_id={$product_id}, pad_variation_id={$variation_id}");

          if(!($order_product instanceof NullPage)) {
            $order_product->{$this->field_options_name} = $cart_product->{$this->db_optcolumn};
            $order_product->save();

          } else {
            $this->logError("No product corresponding to {$product_id}/{$variation_id} in the order");
          }
        }
      }
    }
  }

  /**
   * Add the price of the chosen paid options to the the initial price of the
   * product. Used when displaying the cart, for the client-side order
   * summaries, invoices, and to definitely store the final prices in the orders
   * Act after PadCart::getProductPrice
   */
  public function customizePriceWithOptions($event) {
    $product = $event->arguments('product');
    $product_id = $product->id;
    $variation_id = $event->arguments('variation_id');
    $pricefield = $event->object->pricefield;
    $price = (float) $product->$pricefield;

    $options = $this->getCartProductOptions($product_id, $variation_id);
    $options_price = (float) $this->getCartProductOptionsPrice($options);

    $event->return = $price + $options_price;
  }

  /**
   * Add some JS and css in the header of every PadOpt product page and page
   * of the PadLoper admin
   * Act before Page::render
   */
  public function addScriptsAndStyles($event) {
    $page = $event->object; 
    $module_url = $this->config->urls->siteModules . basename(__DIR__);

    $scripts = <<<EOT
      <script>
        const padopt_logname = '{$this->log_name}';
      </script>
EOT;

    $styles = '';

    // Only for PadOpt product pages
    if($this->isPadoptProductPage($page)) {
      $scripts .= "<script type='text/javascript' src='{$module_url}/templates/scripts/padopt.js'></script>";
      $styles .= "<link type='text/css' href='{$module_url}/templates/styles/padopt.css' rel='stylesheet' />";
    }
    
    // Only for PadLoper admin pages
    elseif($page->template->name == 'admin' && $page->name == 'padloper') {
      $scripts .= "<script type='text/javascript' src='{$module_url}/templates/scripts/padopt_admin.js'></script>";
      $styles .= "<link type='text/css' href='{$module_url}/templates/styles/padopt_admin.css' rel='stylesheet' />";
    }

    if(!empty($styles) || !empty($scripts)) {
      $event->return = str_replace('</head>', "{$styles}{$scripts}</head>", $event->return); 
    }
  }

  /**
   * Change the admin-side order summary views, by injecting new HTML table
   * columns describing the options associated by clients to the products durant
   * their shoppings.
   * Act after PadProcess::executeViewOrder
   */
  public function addOptionsToViewOrder($event) {
    $id = (int) $this->input->get->id;
    $order = $event->object->pages->get($id);
    $page = $event->return;

    preg_match('/<thead>.*<\\/thead>/Us', $page, $thead);
    preg_match('/<tbody>.*<\\/tbody>/Us', $page, $tbody);

    preg_match_all('/<tr>.*<\\/tr>/Us', $tbody[0], $bodyrows);
    $bodyrows = $bodyrows[0];

    // The HTML table of the current view should has as many lines as there are
    // products associated to the order (+ 1 at the end)
    if($order->pad_products->count == count($bodyrows) - 1) {
      $headcols = explode('</th>', $thead[0]);
      $headcols[0] .= '</th><th>' . __("Included Options");

      $thead = implode('</th>', $headcols);

      for($i = 0; $i < count($bodyrows); $i++) {
        $bodycols = explode('</td>', $bodyrows[$i]);
        $bodycols[0] .= '</td><td>';

        // The last line corresponds to the total price of the order
        if($i < count($bodyrows) - 1) {
          $serialized_options = $order->pad_products[$i]->{$this->field_options_name};

          if(!empty($serialized_options)) {
            $options = unserialize($serialized_options);
            $options_list = $this->renderOptionsHtml($options);

            $product_id = $options['product_id'];
            $json_options = json_encode($options);
            $url_options = base64_encode($json_options);
            $view_url = "{$this->pages->get($product_id)->url}#{$url_options}";
        
            $view_buttons = "<a href='{$view_url}' target='_blank'>" . __("View online") . '</a><br />';
            $view_buttons .= "<a href='javascript:;' class='padopt_show_options'>" . __("Show list") . '</a>';

            $bodycols[0] .= $view_buttons.$options_list;
          }
        }

        $bodyrows[$i] = implode('</td>', $bodycols);
      }

      $tbody = '<tbody>' . implode($bodyrows) . '</tbody>';

      $page = preg_replace('/<thead>.*<\\/thead>/Us', $thead, $page, 1);
      $page = preg_replace('/<tbody>.*<\\/tbody>/Us', $tbody, $page, 1);

      $event->return = $page;

    } else {
      $this->logError("Cannot show products options");
    }
  }


  /***********************/
  /** PRIVATE FUNCTIONS **/
  /***********************/

  /**
   * Produce the HTML code corresponding to the options list
   *
   * @param array $options Option values associated to a product
   * @return string HTML code
   */
  private function renderOptionsHtml($options) {
    $options_list = '<ul class="padopt_included_options">';

    foreach($options as $name => $value) {
      if($name != 'product_id') {
        $field = $this->fields->get($name);

        if(!empty($field)) {
          $field_label = $field->label;
          $field_txt = '';

          // Only for filled fields (may be optional)
          if($value != '') {

            // Field with predefined options (eg. select, checkboxes, radios)
            if($field->type instanceof FieldtypeOptions) {
              $field_options = $field->type->getOptions($this->fields->get($name));
  
              // Values composed of multiple values (eg. checkboxes)
              if(strpos($value, '|') !== false) {
                $subvalues = explode('|', $value);
                $field_txt = '<ul>';
    
                foreach($subvalues as $subvalue) {
                  if(is_integer($subvalue)) {
                    $field_option = $field_options->get($subvalue);

                    if(empty(!$field_option)) {
                      $field_txt .= "<li><em>{$field_option->data['title']}</em></li>";
                    } else {
                      $this->logError("Option value {$subvalue} of the field {$name} does not exist");
                    }

                  } else {
                    $this->logError("Subvalue {$subvalue} of the field {$name} must be a number");
                  }
                }
    
                $field_txt .= '</ul>';
    
              // Atomic value (eg. select with one choice)
              } else {
                $field_option = $field_options->get($value);

                if(empty(!$field_option)) {
                  $field_txt = "<em>{$field_option->data['title']}</em>";
                } else {
                  $this->logError("Option value {$value} of the field {$name} does not exist");
                }
              }

            // Free field (eg. text, textarea)
            } else {
              $field_txt = "<em>{$value}</em>";
            }
          }
  
          $options_list .= "<li><strong>{$field_label}:</strong> {$field_txt}</li>";

        } else {
          $this->logError("Select field {$name} does not have options");
        }
      }
    }

    $options_list .= '</ul>';

    return $options_list;
  }

  /**
   * Return the chosen options for a product added in the current cart
   *
   * @param int $product_id 
   * @param in $variation_id
   * @return 
   */
  private function getCartProductOptions($product_id, $variation_id) {
    $sql = "SELECT {$this->db_optcolumn} FROM {$this->db_padcart} WHERE product_id = :product_id AND variation_id = :variation_id AND sess_id = :sess_id LIMIT 1";
    $sth = $this->database->prepare($sql);
    $sth->bindParam(":product_id", $product_id);
    $sth->bindParam(":variation_id", $variation_id);
    $sth->bindParam(":sess_id", $this->session_id);
    $sth->execute();

    $options = array();
    $serialized_options = $sth->fetchAll(\PDO::FETCH_CLASS);

    if(count($serialized_options) > 0) {
      $serialized_options = $serialized_options[0];
      $serialized_options = $serialized_options->{$this->db_optcolumn};

      // Product with PadOpt options
      if(!empty($serialized_options)) {
        $unserialized_options = unserialize($serialized_options);

        if($unserialized_options) {
          $options = $unserialized_options;
        } else {
          $this->logError("Product {$product_id}/{$variation_id} options are not unserializable");
        }
      }

    } else {
      $this->logError("Product {$product_id}/{$variation_id} does not exist in the db for this session");
    }

    return $options;
  }

  /**
   * Extract the price of an option directly from its title
   *
   * @param string $title
   * @return float Extracted price or zero
   */
  private function extractOptionPriceFromTitle($title) {
    $option_price = 0;

    // eg. "With a golden shell (+ 499.99 â‚¬)"
    preg_match('/\s*\(\s*\+\s*([0-9]+(?:[.,][0-9]+)?)\s*.+\s*\)/', $title, $matches);

    if(count($matches) > 1) {
      $option_price = $matches[1];
    }

    return $option_price;
  }

  /**
   * Return the total price of the chosen paid options
   *
   * @param array $options Option values associated to a product
   * @return float
   */
  private function getCartProductOptionsPrice($options) {
    $options_price = 0;

    foreach($options as $name => $value) {
      if($name != 'product_id') {

        // Only for filled fields (may be optional)
        if($value != '') {
          $field = $this->fields->get($name);

          if(!empty($field)) {
  
            // Field with predefined options (eg. select, checkboxes, radios)
            if($field->type instanceof FieldtypeOptions) {
              $field_options = $field->type->getOptions($this->fields->get($name));
        
              if(!empty($field_options)) {

                // Value composed of multiple values (eg. checkboxes)
                if(strpos($value, '|') !== false) {
                  $subvalues = explode('|', $value);
          
                  foreach($subvalues as $subvalue) {
                    if(is_integer($subvalue)) {
                      $field_option = $field_options->get($subvalue);
  
                      if(empty(!$field_option)) {
                        $options_price += $this->extractOptionPriceFromTitle($field_option->data['title']);
                      } else {
                        $this->logError("Option value {$subvalue} of the field {$name} does not exist");
                      }

                    } else {
                      $this->logError("Subvalue {$subvalue} of the field {$name} must be a number");
                    }
                  }

                // Atomic value (eg. select with one choice)
                } else {
                  $field_option = $field_options->get($value);
  
                  if(empty(!$field_option)) {
                    $options_price += $this->extractOptionPriceFromTitle($field_option->data['title']);
                  } else {
                    $this->logError("Option value {$value} of the field {$name} does not exist");
                  }
                }
              } else {
                $this->logError("Select field {$name} does not have options");
              }
  
            // Free field (eg. text, textarea)
            } else {
              $options_price += $this->extractOptionPriceFromTitle($field->label);
            }
          } else {
            $this->logError("Field {$name} does not exist");
          }
        }
      }
    }

    return $options_price;
  }

  /**
   * Error logging
   *
   * @param string $msg
   */
  private function logError($msg) {
    $this->error($msg);
    $this->log->save($this->log_name, $msg);
  }


  /**********************/
  /** PUBLIC FUNCTIONS **/
  /**********************/

  /**
   * A submodule is just another PW module but designed to add functionnalities
   * to PadOpt. Registred submodules are used in renderFieldset
   * 
   * @param PadOptSubmodule $submodule
   */
  public function registerSubmodule($submodule) {
    $input_prefix = $submodule->getInputPrefix();
    $this->registered_submodules["{$this->general_prefix}{$input_prefix}"] = $submodule;
  }

  /**
   * Return the HTML code of the input fields to add to the PadLoper form, in
   * which there is the "Add to cart" button. This function should be called
   * from a PadOpt product template, with a <field_tpl_name> field defined
   *
   * @return string HTML code
   */
  public function renderFieldset() {

    // The template to use to build the fieldset is defined from the
    // <field_tpl_name> field of the current page
    $template = $this->templates->get($this->page->get($this->field_tpl_name));

    // Creation of a temporary page, just to associate it with the template and
    // to transform the template fields into input fields
    $page = new Page();
    $page->template = $template;
    $inputfields = $page->getInputfields();

    $inputfield_groups = array();
    $inputfield_groups_id = 0;
    
    // Step 1: Group together all fields that follow each other with an identical prefix in their name
    foreach($inputfields as $inputfield) {

      // Extracts the prefix (format <general-prefix>_<type-prefix>_)
      preg_match("/^{$this->general_prefix}[^_]+_/", $inputfield->name, $prefix);

      if(!empty($prefix)) {
        $prefix = $prefix[0];

        if(empty($inputfield_groups)) {
          $inputfield_groups[] = array(
            'prefix' => $prefix,
            'inputfields' => array($inputfield),
          );

        } else {
          if($inputfield_groups[$inputfield_groups_id]['prefix'] == $prefix) {
            $inputfield_groups[$inputfield_groups_id]['inputfields'][] = $inputfield;

          } else {
            $inputfield_groups_id++;
            $inputfield_groups[$inputfield_groups_id]['prefix'] = $prefix;
            $inputfield_groups[$inputfield_groups_id]['inputfields'][] = $inputfield;
          }
        }
      }
    }

    $product_id = $this->page->id;
    $variation_id = -1;

    // The variation_id is always different because the chosen options are (potentially) always different
    $i = 0;
    do {
      $variation_id = rand(100000, 10000000);

      if($i++ > 1000) {
        $this->logError("Variation ID cannot be generated");
        exit();
      }
    } while(!($this->pages->get("pad_product_id={$product_id}, pad_variation_id={$variation_id}") instanceof NullPage));

    // This hidden input is required to ask the other processes to take the options into account
    $render = "<input type='hidden' name='{$this->input_padopt_enabled}' value='1' />";

    $render .= "<input type='hidden' name='product_id' value='{$product_id}' />";
    $render .= "<input type='hidden' name='variation_id' value='{$variation_id}' />";

    // Step 2: Produce HTML output from each group of fields
    foreach($inputfield_groups as $inputfield_group) {

      // Group of separators (ie. titles with optional description/notes)
      if($inputfield_group['prefix'] == "{$this->general_prefix}{$this->separator_prefix}") {
        $separators = '';

        foreach($inputfield_group['inputfields'] as $inputfield) {
          $separators .= "<h2>{$inputfield->label}</h2>";
  
          if(!empty($inputfield->description)) {
            $separators .= "<div class='{$this->general_prefix}{$this->separator_prefix}_description'>{$inputfield->description}</div>";
          }
  
          if(!empty($inputfield->notes)) {
            $separators .= "<div class='{$this->general_prefix}{$this->separator_prefix}_notes'>{$inputfield->notes}</div>";
          }
        }

        $render .= $separators;

      // Group of core input fields (ie. field types available in PW)
      } elseif($inputfield_group['prefix'] == "{$this->general_prefix}{$this->input_prefix}") {
        $form = $this->modules->get('InputfieldForm');

        foreach($inputfield_group['inputfields'] as $inputfield) {
          $form->add($inputfield);
        }

        // PW produces the HTML code by itself
        $form_render = $form->render();

        // <form> tags are not necessary because it is supposed to be a form part
        $render .= preg_replace('/<\/?form[^>]*>/', '', $form_render);

      // Group of fields defined for a registred submodule
      } elseif(isset($this->registered_submodules[$inputfield_group['prefix']])) {
        $render .= $this->registered_submodules[$inputfield_group['prefix']]->render($inputfield_group['inputfields']);
      }
    }

    return $render;
  }

  /**
   * Return information about the options of a product currently available in the cart
   *
   * @param Page $product
   * @return array 0=Options URL, 1=HTML options list, 2=Total options price
   */
  public function getCartProductOptionsInfos($product) {
    $options = $this->getCartProductOptions($product->product_id, $product->variation_id);
    $view_url = '';
    $options_list = '';
    $options_price = '';

    if(!empty($options)) {
      $json_options = json_encode($options);
      $url_options = base64_encode($json_options);
  
      $view_url = "{$this->pages->get($product->product_id)->url}#{$url_options}";
      $options_list = $this->renderOptionsHtml($options);
      $options_price = $this->getCartProductOptionsPrice($options);
    }

    $infos = array($view_url, $options_list, $options_price);
    
    return $infos;
  }

  /**
    * Return true if the page seems to be a PadOpt product page (ie. a PadLoper
    * product page but with PadOpt options)
    *
    * @param Page $page
    * @return bool
    */
  public function isPadoptProductPage($page) {
    return $page->template->fields->get($this->field_tpl_name);
  }

  /**
    * Module installation
    */
  public function install() {

    // Add a column for product options to the table used for storing carts, before ordering
    // Options are PHP-serialized
    $sql = "ALTER TABLE {$this->db_padcart} ADD {$this->db_optcolumn} TEXT DEFAULT NULL";
    $this->database->exec($sql);

    $this->message("Created new SQL column {$this->db_optcolumn} in carts");

    // Field used in PadOpt product templates, to save the id of the template
    // with which the option input fields set will be built
    $field_tpl = new Field();
    $field_tpl->type = $this->modules->get('FieldtypeInteger');
    $field_tpl->name = $this->field_tpl_name;
    $field_tpl->label = 'Form Template Id for PadOpt pages';
    $field_tpl->description = 'Id of the template to use to build the options form in PadOpt pages.';
    $field_tpl->save();

    $this->message("Created new field {$field_tpl}");

    // Field used to store product options, when a cart (MySQL) is transform
    // into an order (PW Page)
    $field_options = new Field();
    $field_options->type = $this->modules->get('FieldtypeTextarea');
    $field_options->name = $this->field_options_name;
    $field_options->label = 'Order Options for PadLoper';
    $field_options->description = 'Options associated to the order, chosen by the client.';
    $field_options->save();

    $this->message("Created new field {$field_options}");

    $padorder_product = $this->templates->get('padorder_product');
    $padorder_product->fields->add($field_options);
    $padorder_product->fields->save();

    $this->message("Added field {$field_options} to the padorder_product template");
  }

  /**
    * Module uninstallation
    */
  public function uninstall() {
    $padorder_product = $this->templates->get('padorder_product');
    $field_options = $this->fields->get($this->field_options_name);
    $padorder_product->fields->remove($field_options);
    $padorder_product->fields->save();

    $this->message("Removed field {$field_options} from the padorder_product template");

    $this->fields->delete($field_options);
    $this->message("Removed field {$field_options}");

    $field_tpl = $this->fields->get($this->field_tpl_name);
    $this->fields->delete($field_tpl);
    $this->message("Removed field {$field_tpl}");

    $sql = "ALTER TABLE {$this->db_padcart} DROP {$this->db_optcolumn}";
    $this->database->exec($sql);

    $this->message("Dropped SQL column {$this->db_optcolumn} in carts");
  }

  public function getGeneralPrefix() {
    return $this->general_prefix;
  }

  public function getLogName() {
    return $this->log_name;
  }
}
